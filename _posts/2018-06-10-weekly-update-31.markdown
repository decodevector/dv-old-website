---
layout: post
title:  "Week 31: Talking to Computers"
date:   2018-06-10 23:45:00 +0530
categories: Notes Update
tags:
author: Gaurav Singh
---

After seeing some hope last week, I was excited about this week but this week has been complete drought. I'm tired of repeating myself now if you do not take efforts, I don't care. Despite, I will continue with what least I can do.

This week, I'm writing my account of ups and downs in learning computer science. Hopefully, you might take a lesson or two from my experience.

I'm a self-taught computer programmer and started much earlier to my benefit. I was conversant with the BASIC and C++ in my early secondary school solely by sitting next to my father when he used to code at home. I think I was in awe of how computers work! I still get intrigued by simplest of the programs like Hello World! Isn't it amazing that a few transistors and electricity together is displaying a string of characters on display! Its mind boggling that we(humans) have achieved so much and computers have now surpassed humans in many areas, and one can only imagine what can be made when humans and machine work in synergy. Together, we have this abundance of creative intelligence which has the potential to solve the biggest of the problems we have. Possibly that is why computers are called as the literacy for the 21st century. This is what excites me! Being able to talk to computers is unbelievable, it is like an additional thinking capability, computers are excellent in some of the areas where humans can only imagine. Telecommunication to Education to Space tech to watching that cat video on your phone, its all through computers! And programming is one of the undiluted ways to talk to machines. I wanted to push the envelope and investigated how I can get better and better at 'talking' to computers. Maths' was the answer! The computer instructions are arithmetic operations done on hundreds to thousands of adders made from the transistors. Later, I taught myself to code on Intel 8008, and I was blown away by this marvel. I'm still very inclined to low-level programming and wanted to program in a language where I get most control of the machine which higher-level programming language prohibits. One of the key things that helped me learn programming languages without much pain was my experience with low-level languages first. I know what happens when a variable is declared or a loop is running, deep down to the memory or microprocessor.

> The Analytical Engine weaves Algebraical patterns just as the Jacquard loom weaves flowers and leaves. - - A. Augusta, Countess of Lovelace, on Babbage's Analytical Engine

On the contrary, there is now an uncountable number of online courses available to teach programming of which most skip the fundamental understanding of computers and focus on getting simple and necessary things done. While there is inherently no problem with these courses, but how one consumes this information and often takes shortcuts to get things done faster. Learning to code is similar to learning a language. Can you imagine learning a language (say English or Hindi) in the way programming tutorials do? You are must fluent and comfortable in speaking your mother tongue, and you learned that making mistakes, discovered by some hand-holding, learned by understanding the alphabet, grammar, rules of the language but step by step, gradually. Do not learn in haste but learn on a daily basis. Unlike most people, I never worried about knowing the syntaxes or knowing how to compile a program. My point of concern was always the problem that I'm trying to solve through the code.

> No matter how far down the wrong road you have gone, turn back now. - Anonymous Turkish Proverb

Much later, I learned C (the predecessor of C++) and could see how things were abstracted, made more accessible to the end programmer. And today we have way more simplified syntaxes to get things done. Can I at least ask members of DV to not fall into the trap, do not look for shortcuts. Find how the computer executes each instruction, and you will learn a great deal of information which is instrumental in this process of learning programming. After that, I tried with various languages and settled with C++. C++ is of course not the best language, but there is, in fact, no best language. Computer languages are generally developed to do a specific task, and C++ fits my need for scientific computing back in time. You would, of course, require HTML to code a web page, and C++ cannot get much over there.

I think just the documentation of a programming language you're working with is enough for you to learn that language. You would find all syntaxes and constructs in it. And the rest will be simplified by me during the classes.

Later I started solving problems (like PSETs) to get more and more comfortable with computers, and you would be amazed by how much you can get comfortable with speaking to computers! To me, it is like daily exercise one would do to keep their body fit. I have not stopped that even now, I do problems like these to get better and to be able to solve the more significant problems that I'm targeting at.

Okay, all of these are ups in my journey, where is the down? I have not had downs yet, but I'm ready to embrace it. Oh yes, just one that I can recall is that I was denied Computer Science during my eleventh standard admission.

This is a small and abstracted and incomplete account of my journey with programming for you to have at least one takeaway but as I'm writing this sentence, I think this may encourage new-comers towards low-level programming. It's okay if you don't understand the difference between low-level and high-level yet. I will cover it in subsequent posts in the future.

Please do not solve PSETs by referring to examples on the internet; it will dilute your learning process. You are only allowed to see the programming language documentation. Python documentation in this case. And that's' all!

## What's New?
- Minor changes in look and feel of the website.
- Minor bug fixes in the DV website.

## And so farâ€¦
- Most PSET problems solved (this week): None
- Most PSET problems solved (all-time): Simran (38)
- Most rating (this week): Simran (22)
- Most rating (all-time): Simran (22)
- Best streak: Simran (04/05/2018-08/05/2018 .. 5 days)
- Most PSET problems solved in one day: Simran (04/04/2018 .. 9 problems, 16/04/2018 .. 9 problems)

So, who is finding difficulty to do PSETs and who is ready to take on the even more upcoming difficult challenge in DV?

> You should figure out programs as you're writing them, just as writers and painters and achitects do. Realizing this [programming as sketching] has real implications for software design. It means that a programming language should, above all, be malleable. A programming language is for thinking of programs, not for expressing programs you've already thought of. It should be a pencil, not pen. [...] Remember too that languages are not primarily a form for finished programs, but something that programs have to be developed in. [...] A good programming language should, like oil paint, make it easy to change your mind.[...] Paintings usually begin with a sketch. Gradually the details get filled in. But it is not merely a process of filling in. Sometimes the original plans turn out to be mistaken. Countless paintings, when you look at them in x-rays, turn out to have limbs that have been moved or facial features that have been readjusted.[...] So the test of a language is not simply how clean the finished program looks in it, but how clean the path to the finished program was [...] What made oil paint so exciting, when it first became popular in the fifteenth century, was that you could make the finished work from the prototype. You could make a preliminary drawing if you wanted to, but you weren't held to it; you could work out all the details, and even make major changes as you finished the painting. You can do this with software too. A prototype doesn't have to be just a model; you can refine it into the finished product....it's good for morale [...] Building something by gradually refining a prototype is good for morale because it keeps you engaged. In software, my rule is: always have working code. If you're writing something you'll be able to test in an hour, you have the prospect of an immediate reward to motivate you. - P. Graham (in "Hackers and Painters" pg. 22, 27, 218, 219, 220, 221)
